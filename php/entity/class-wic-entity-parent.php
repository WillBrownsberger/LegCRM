<?php
/*
*
* class-wic-entity-parent.php
*
* base class for wp issues crm tables/entities -- instantiates particular object in the constructor
*
*
* 
*/

abstract class WIC_Entity_Parent {
	
	protected $entity		= ''; 						// e.g., constituent, activity, issue
	protected $entity_instance = '';					// relevant where entity is a row of multivalue array as in emails for a constituent
	protected $fields = array(); 						// will be initialized as field_slug => type array
	protected $data_object_array = array(); 			// will be initialized as field_slug => control object 
	protected $outcome = '';							// results of latest request 
	protected $outcome_dups = false;					// supplementary outcome information -- dups among error causes
	protected $outcome_dups_query_object;				// results of dup query for listing	
	protected $explanation	= '';						// explanation for outcome
	protected $search_log_id = '';						// if generated by wic_query
	protected $show_dup_list = false;					// override on construct if wish to actually show a dup list on update as for constituents
	protected static $entity_dictionary;


	abstract protected function set_entity_parms ( $args ); // must be included in child to set entity and possibly instance 
	/*
	*
	* constructor just initializes minimal blank structure and passes control to named action requested
	* 
	* note that the current class is an abstract parent class WIC_Entity_Parent
	* 	-- entity is chosen in the wp-issues-crm which initializes the corresponding child class  -- e.g. WIC_Constituent
	*  
	* args is an associative array, which MAY be populated as follows:
	*		'id_requested'			=>	$control_array[2] passed by wp-issues-crm from form button for an ID search
	*		'instance'				=> passed in the case of the object being initialized as a row in multi-value field:	
	*		'id_array'				=> array of id's -- used when passed from issue form to comment entity for conversion to constituent listing
	*		'search_id'				=> pass through of issue search log id that will be used to reconstruct constituent search
	*
	*/
	public function __construct ( $action_requested, $args ) {
		$this->set_entity_parms( $args );
		$this->$action_requested( $args );
	}



	/*************************************************************************************
	*
	*  METHODS FOR SETTING UP AND POPULATING THE DATA_OBJECT_ARRAY
	*
	**************************************************************************************
	*
	* The major entities retain their logical properties in a single data_object_array of control objects
	*	Some of these controls are multivalue controls, which in turn are arrays of entity objects each with their own array of controls
	*	Have to handle the multivalue controls as arrays.
	*
	* To setup up the entity object (this sequence is built in to each populate function): 
	*  (1) get the entity fields/properties 
	*  (2) initialize the data object array by instantiating controls for each (each dictionary control type having a corresponding control class )
	*  (3) populate the control objects -- from a submitted form, from a found record, with search parameters or just initialize
	*
	*/
	public static function get_entity_dictionary() {
		return static::$entity_dictionary;
	}

	public static function get_option_group( $group ) {
		if ( isset ( static::$option_groups[$group]) ) {
			return static::$option_groups[$group];
		} else {
			return false;
		}
	}

	// simplifies and reformats fields into $this->fields
	public  function initialize_fields () { 
		$form = 'WIC_Form_'. $this->entity;  
		$fields = $form::list_field_slugs(); 
		// returns array of row objects, one for each field 
		foreach ( $fields as $field ) { 
			if ( '' == $field) continue;
			$this->fields[] = (object) array ( 'field_slug' => $field, 'field_type' => static::$entity_dictionary[$field]['field_type']);
		}
	}	

	protected function initialize_data_object_array()  {
		// set up fields
		$this->initialize_fields();
		// initialize_data_object_array as field_slug => control object 
		foreach ( $this->fields as $field ) { 
			$this->data_object_array[$field->field_slug] = WIC_Control_Factory::make_a_control( $field->field_type );
			$this->data_object_array[$field->field_slug]->initialize_default_values( $this->entity, $field->field_slug, $this->entity_instance );
		}		
	}

	protected function populate_data_object_array_from_submitted_form() {

		$this->initialize_data_object_array();

		foreach ( $this->fields as $field ) {
			if ( isset ( $_POST[$field->field_slug] ) ) {		
				$this->data_object_array[$field->field_slug]->set_value( $_POST[$field->field_slug] );
			} else {
				// this branch necessary because a checked value with a true default should be reset if coming from form
				$this->data_object_array[$field->field_slug]->reset_value();
			}	
		}
		$this->main_form_field_interaction_rules(); 
	}	

	protected function populate_data_object_array_from_found_record( &$wic_query, $offset=0 ) { 

		$this->initialize_data_object_array();

		foreach ( $this->data_object_array as $field_slug => $control ) { 
			if ( ! $control->is_multivalue() && ! $control->is_transient()  ) { 
				$control->set_value ( $wic_query->result[$offset]->{$field_slug} );
			} elseif ( $control->is_multivalue() ) { // for multivalue fields, set_value wants array of row arrays -- 
						// query results don't have that form or even an appropriate field slug, 
						// so have to search by parent ID  
				$control->set_value_by_parent_pointer( $wic_query->result[$offset]->ID );
			}
		} 
		$this->main_form_field_interaction_rules(); 
	}	

	// hook to work with fields after population from form
	protected function main_form_field_interaction_rules() {}

	// override in advanced search entity
	protected function populate_data_object_array_with_search_parameters ( $search ) {}
	/*************************************************************************************
	*
	*  METHODS FOR SANITIZING VALIDATING THE DATA_OBJECT_ARRAY
	*     Results stored in object properties -- outcome, outcome_dups, explanation
	*
	*	  Note that sanitize and validation performed on all fields if record is_changed -- some waste on unchanged fields,
	*		but most expensive validations are at the row level and these are not performed if the row is unchanged b/c 
	*		the is_changed flag will be checked again when this object is being used as a row object within a multivalue control.
	*		(Required checking and dup checking are necessary if there has been any record change -- can not be limited to changed fields).
	*	  If is_changed flag is not set, then operating as an uploader entity and want to always sanitize/validate
	*
	**************************************************************************************/
	private function update_ready( $save ) { // true is save, false is update
		// runs all four sanitize/validate functions
		$this->sanitize_values();
		$this->validate_values();
		// don't clutter with additional messages if validation fails.
		if ( '' === $this->outcome ) {
			$this->required_check();
		}
		// do dup check last -- required fields are part of dup check
		// outcome starts as empty string, set to false if validation or required errors
		// check that dup checking not overriden
		if ( '' === $this->outcome && ! isset ( $_POST['no_dupcheck'] ) ) {		
			$this->dup_check ( $save );
		}
	}
	
	// sanitize values regardless of change status 
	public function sanitize_values() {
		foreach ( $this->data_object_array as $field => $control ) {
			$control->sanitize();
		}
	}
	
	// check for dups -- $save is true/false for save/update (not a row level function, so no need to test is_changed)
	protected function dup_check ( $save ) {
		$dup_check = false;
		// first check whether any fields are set for dup checking
		foreach ( $this->data_object_array as $field_slug => $control ) {
			if	( $control->dup_check() ) {
				$dup_check = true;
			}	
		}
		
		// if there are some dup check fields defined, proceed to do do dupcheck	
		if ( $dup_check ) {
			$wic_query = WIC_DB_Access_Factory::make_a_db_access_object( $this->entity );
			$search_parameters = array(
				'select_mode' => 'id', // will get details for the list only if needed in next step
			);
			// assembling meta_query with dedup requested
			$wic_query->search ( $this->assemble_meta_query_array( true ), $search_parameters );  // true indicates a dedup search
			if 	( 
					$wic_query->found_count > 1 || // more than one is never OK
					( $wic_query->found_count > 0 && $save )|| // for save, dups are never OK
					( 1 == $wic_query->found_count && $wic_query->result[0]->ID != $this->data_object_array['ID']->get_value() ) // for update, 1 group OK iff same record
				) { 
				$this->outcome = false;
				$this->explanation .= 'Other records found with same combination of name and address.';
				$this->outcome_dups = true;
				$wic_query->list(); // take base query id list and expand to include all constituent fields
				$wic_query->result = $wic_query->list_result; // spoof into result slot
				$this->outcome_dups_query_object = $wic_query;
				$this->outcome_dups_query_object->strip_an_item ( $this->data_object_array['ID']->get_value() ); 
			}
		}		 
	}

	// note this entity level validation routine only runs in response to form -- controls are validated individually by the uploader
	public function validate_values() {
		
		if ( isset ( $this->data_object_array['is_changed'] ) && '0' === $this->data_object_array['is_changed']->get_value() ) {
			return '';
		}
		
		// have each control validate itself and report -- stop if hit one error message
		$validation_errors = '';		
		foreach ( $this->data_object_array as $field => $control ) {
			$validation_errors = $control->validate();
			if ( $validation_errors > '' ) {
				$this->outcome = false;		
				$this->explanation .= $validation_errors;
				break;		
			} 
		}
		// returning with first validation error or with blank if none; 
		return $validation_errors;		
	}

	public function required_check () {
		
		// have each control see if it is present as required 
		$required_errors = '';
		$there_is_a_required_group = false;
		$a_required_group_member_is_present = false;		
		foreach ( $this->data_object_array as $field_slug => $control ) {
			$required_errors .= $control->required_check();	
			if ( $control->is_group_required() ) {
				$there_is_a_required_group = true;			
				$a_required_group_member_is_present = $control->is_present() ? true : $a_required_group_member_is_present ;
			}
		}
		// report cross-control group required result
		if ( $there_is_a_required_group && ! $a_required_group_member_is_present ) {	
			$required_errors .= sprintf ( ' At least one among %s is required. ', $this->get_required_string() );
		}
		if ( $required_errors > '' ) {
			$this->outcome = false;
			$this->explanation .= $required_errors;		
		}
		
		return ( $required_errors );
   }

   protected function get_required_string() {
	    $required_array = array();
		foreach (static::$entity_dictionary as $field => $details ) {
			if ( 'group' == $details['required'] ) {
				$required_array[] = $details['field_label'];
			}
		}
		return implode(',', $required_array );
	}

	/*************************************************************************************
	*
	*  METHODS FOR COMPILING SEARCH REQUESTS FROM CONTROLS 
	*	This function lives in this class so that it can be called publicly by a multivalue control
	*	   which may be assembling query conditions from entities within it to contribute to a 
	*     search involving a multi-table join.  The corresponding update assembly lives in the database access
	*		layer which, although it will support multi-entity searches, only updates one entity.
	*
	*  It is called in this class by dedup, id search and form search functions and also in the multivalue control class
	*
	*
	**************************************************************************************/
	public function assemble_meta_query_array ( $dup_check ) {
		$meta_query_array = array ();
		foreach ( $this->data_object_array as $field => $control ) {
			$query_clause = '';
			if ( ! $dup_check || $control->dup_check() ) { // all fields if not dupchecking, otw, only dup_check fields
				$query_clause = $control->create_search_clause(); // on multivalue, dup check is automatically true
				if ( is_array ( $query_clause ) ) { // not making array elements unless field returned a query clause
					$meta_query_array = array_merge ( $meta_query_array, $query_clause ); // will do append since the arrays of arrays are not keyed arrays 
				}
			}
		}	
		return $meta_query_array;
	}	

	/*************************************************************************************
	*
	*  SIMPLE FORM REQUEST HANDLERS
	*
	**************************************************************************************/

	protected function new_blank_form( $args = '', $guidance = '' ) { 
		$this->initialize_data_object_array();
		$this->set_special_defaults ( $this->data_object_array );
		$form =  'WIC_Form_' . $this->entity;
		$new_blank_form = new $form;
		$new_blank_form->layout_form( $this->data_object_array, $guidance, 'guidance' );
	}	
	
	// used to recreate form when changing search parameters ( $search is array from get_search_from_search_log )
	// now only used for advanced search, so no populate function in parent
	protected function search_form_from_search_array ( $search ) {
		$this->populate_data_object_array_with_search_parameters ( $search ); 
		$form =  'WIC_Form_' . $this->entity;
		$new_search = new $form;
		$new_search->layout_form( $this->data_object_array, 'Redo Search', 'guidance' );
	}


	/*************************************************************************************
	*
	* REQUEST HANDLER FOR SAVE UPDATE REQUESTS
	*
	*************************************************************************************/
	//handle an update request coming from a form 
	protected function form_save_update () {
		// populate the array from the submitted form
		$this->populate_data_object_array_from_submitted_form();
		$save = ( 0 == $this->data_object_array['ID']->get_value() || '' == $this->data_object_array['ID']->get_value() ); // 8.0, empty string != 0
		$form_class = 'WIC_Form_' . $this->entity;

		// return with no changes message if nothing to do
		if ( '0' === $this->data_object_array['is_changed']->get_value() ) {
			$this->sanitize_values(); // need to sanitize values before returning them ;
			$message =  'No changes to save -- no action taken.';
			$message_level = 'error';
			$form = new $form_class;
			$form->layout_form ( $this->data_object_array, $message, $message_level );
			return;
		}

		// validate the array
		$this->update_ready( $save ); // false, not a save
		// if issues, show the fail form with messages; if dups, show the list of dups 
		if ( false === $this->outcome ) {
			$message = 'Not successful: ' . $this->explanation;
			$message_level = 'error';
			$form = new $form_class;
			$form->layout_form ( $this->data_object_array, $message, $message_level );
			if ( $this->outcome_dups && $this->show_dup_list ) {	
				$lister_class = 'WIC_List_' . $this->entity;
				$lister = new $lister_class;
				$list = $lister->format_entity_list( $this->outcome_dups_query_object, '' );
				echo $list;
			}	
			return;
		}

		// form was good so do save/update
		$wic_access_object = WIC_DB_Access_Factory::make_a_db_access_object( $this->entity );
		$wic_access_object->save_update( $this->data_object_array );
		// handle failed save/update 
		if ( false === $wic_access_object->outcome ) {
			$message =  $wic_access_object->explanation;
			$message_level = 'error';
			$form = new $form_class;
			$form->layout_form ( $this->data_object_array, $message, $message_level );
		// proceed on successful save/update
		} else {
			if ( $save ) { 
				// retrieve the new ID from the save process
				$this->data_object_array['ID']->set_value( $wic_access_object->insert_id );
			}
			// populate any other values like ID which come from the update process
			$this->special_entity_value_hook( $wic_access_object ); // done on both save and updates, but hook may test values
			// show success form
			$message = 'Successful.  You can update further. ';
			$message_level = 'good_news';
			$this->reset_changed_flags();
			$form = new $form_class;
			$form->layout_form ( $this->data_object_array, $message, $message_level );					
		}
	}

	/*************************************************************************************
	*
	* REQUEST HANDLER FOR SEARCH REQUESTS -- BY ID, FROM FORM, FROM SAVED SEARCH ARRAY 
	*
	* parms are id_requested, success_form and return_object
	*************************************************************************************/
	protected function id_search ( $args ) {
		$id = $args['id_requested']; 
		
		// success form arg supports uploads which do forms in multiple stages
		$success_form = isset ( $args['success_form'] ) ? $args['success_form'] : 'WIC_Form_' . $this->entity;

		// initialize data array with only the ID 
		$this->data_object_array['ID'] = WIC_Control_Factory::make_a_control( 'text' );
		$this->data_object_array['ID']->initialize_default_values(  $this->entity, 'ID', $this->entity_instance );	
		$this->data_object_array['ID']->set_value( $id );
		// set up search object
		$wic_query = WIC_DB_Access_Factory::make_a_db_access_object( $this->entity );
		// set up parameters
		$search_parameters = array(
			'select_mode' => '*',
		);

		$wic_query->search ( $this->assemble_meta_query_array( false ), $search_parameters ); 
		// retrieve record if found, otherwise error
		if ( 1 == $wic_query->found_count ) { 
			$message = '';
			$message_level =  'guidance';
			$this->populate_data_object_array_from_found_record ( $wic_query );			
			$update_form = new $success_form; 
			if ( isset ( $args['return_object'] ) ) {
				return $update_form->get_form_object( $this->data_object_array, $message, $message_level );
			} else {
				$update_form->layout_form ( $this->data_object_array, $message, $message_level );
			}	
		} else {
			printf ( '<h3 class = "bad-record-request-header">Requested a record that has been trashed or no longer exists -- type "%1$s" with ID "%2$s".</h3>' , $this->entity, $id );	
		} 
	}


	public function reset_changed_flags () {
		if ( isset ( $this->data_object_array['is_changed'] ) ) {
			$this->data_object_array['is_changed']->set_value ( '0' );
		}
		
		// if the current entity is not a multivalue row, look for controls that are multivalue blocks of rows
		if ( ! is_subclass_of ( $this, 'WIC_Entity_Multivalue' ) ) {
			foreach ( $this->data_object_array as $key => $control ) {
				if ( $control->is_multivalue() ) {
					$control->reset_changed_flags(); // calls version of reset changed flags defined WIC_Control_Multivalue
				}
			}
		}
	}

	protected function set_special_defaults ( &$wic_access_object ) {
		// available to set default values in new form generic
	}

	// return the ID of the object
	public function get_the_current_ID () {
		return (  $this->data_object_array['ID']->get_value() );
	}

	protected function special_entity_value_hook ( &$wic_access_object ) {
		// available to bring back values from save/update for entity where a value is created by the save process
		// must have correlated language in the save process -- see wic-entity-issue and wic-entity-data-dictionary
	}
	
	public function get_search_log_id () {
		return ( $this->search_log_id > 0 ? $this->search_log_id : false ); // https://www.php.net/manual/en/migration80.incompatible.php
	}
	
	public function get_outcome () {
		return ( $this->outcome );
	}
	
	public function get_ID () {
		return ( $this->data_object_array['ID']->get_value() );
	}
}

